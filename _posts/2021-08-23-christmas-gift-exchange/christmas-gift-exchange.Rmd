---
title: "Secret Santa R Script"
description: |
  A script I created to automate my family's yearly secret santa gift exchange
author:
  - name: Peter Menzies
    url: {}
date: 08-23-2021
output:
  distill::distill_article:
    self_contained: false
categories:
  - R
slug: "2021-23-08-secret-santa-r-script"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### My family's yearly gift exchange

Here's a little context needed to understand the program I created, before we get to the actual code. 

Each year my extended family does a secret santa gift exchange where each member of the family is randomly paired with another â€” the one caveat being that each person must be matched with someone outside of their nuclear family. Traditionally, the matches are assigned using the good old "pick a name from the hat" method. If you draw a name from within your immediate family, you try again until you get someone who isn't. This process seemed like an excellent candidate for automation, and with a couple weeks of R under my belt, it felt like a perfect task to apply what I had learned so far.

### Packages used: `tidyverse` and `here`

```{r}
library(tidyverse)
library(here)
```


### Creating data frame with family member's and their corresponding family unit

I read in a CSV that contains two variables we care about: `Person` and `Group`. Each family member is listed in the `Person` column, and the label created for their family unit under `Group`. 

```{r}
xmas_names <- read_csv(here::here("data", "xmas_names.csv")) %>% 
  select(Person, Group) 
```

### Creating the function

I want to create a function that outputs a data frame with two columns `Giver` and `Recipient`, that lists each member of my family and who they will be giving a gift to. 

Let's start by preemptively creating this object, `ouput_df`, before we get into the for loop. I've made a data frame of the proper dimensions, and also a vector that we'll later populate with the names of those that have already been matched.

```{r}
output_df <- data.frame(Giver = seq(1:nrow(xmas_names)), Recipient = seq(1:nrow(xmas_names)))
already_matched <- vector(mode = "character")
```

### For loop

Within our function we'll have a for loop that iterates through each row in our `xmas_names` data frame and randomly pairs the `Person` in each row with another person from outside of their immediate family unit. 

We'll iterate along the sequence `1:nrow(xmas_names)` 

In order to adjust our pool of "allowable" matches each iteration we're going to create a temporary data frame, `temp_names`, that is first bound to xmas_names and then filtered based on our two criteria: the person cannot be in the same `Group` (family unit) and cannot have already been matched with someone else already. We'll use `dplyr::filter()` to subset `temp_names` to meet these parameters.

Next, before the loop goes any further we'll need to add an `if` statement that saves our function from hitting a dead end. Depending on the order in which matches are randomly assigned, sometimes only members of a single family unit remain in the final iterations. When this happens, our `temp_names` will be empty because there are no longer any viable matches, and our code will break. The `if` statement will just return our function when `TRUE`, so the function will continue to be called until we get a sequence of matches that works!

Next we're going to generate a random number using the `sample()` function and assign it to `sample_number`. This number will be used to index our random match. The number has to be in the range `1:nrow(temp_names)` because `temp_names` is our temporary data frame of viable match candidates. 

We'll use `sample_number` to index `temp_names$Person` and assign that value to `xmas_match`. For consistency, we'll assign the person currently being matched to `matchee`.

Now we need to `append()` our current `xmas_match` to our vector `already_matched` which is used to filter `temp_names` so that person can't be matched with anyone else.



```{r}

```


