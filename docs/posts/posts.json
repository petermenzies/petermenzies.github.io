[
  {
    "path": "posts/2021-08-26-some-r-functions/",
    "title": "Some R functions",
    "description": "A short description of the post.",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-08-26",
    "categories": [],
    "contents": "\nExample: use values from a data frame to calc something based on the user input\n\n\n# calculate the groundwater transport rate\n\ngw_rate <- function(site) {\n  \n  gw_slope_depth <- data.frame(sitename = c(\"mountain\", \"prairie\", \"desert\", \"beach\"),\n                               depth = c(32, 41, 63, 2),\n                               slope = c(11.3, 0.4, 0.8, 2.6))\n  site_select <- filter(gw_slope_depth, sitename == site)\n  \n  transport_rate <- 1.4 * site_select$slope + 3.6 * site_select$depth\n  \n  return(transport_rate)\n  \n}\n\ngw_rate(\"beach\")\n\n\n[1] 10.84\n\nNow using switch()\n\n\ngw_rate_switch <- function(site) {\n  gw_slope_depth <- switch(site,\n                           \"mountain\" = c(32, 11.3),\n                           \"prairie\" = c(41, 0.4),\n                           \"desert\" = c(63, 0.8),\n                           \"beach\" = c(2, 2.6))\n  \n  transport_rate <- 1.4 * gw_slope_depth[2] + 3.6 * gw_slope_depth[1]\n  \n  return(transport_rate)\n  \n}\n\nbeach_rate <- gw_rate_switch(\"beach\")\n\nbeach_rate\n\n\n[1] 10.84\n\nLogistic growth modeling\n\n\nlogistic_growth <- function(K, N0, r, time) {\n  Nt <- K / (1+((K - N0) / N0) * exp(-r * time))\n  print(Nt)\n}\n\nlogistic_growth(K = 5000, N0 = 200, r = 0.43, time = 6)\n\ntime_vec <- seq(from = 0, to = 35, by = 0.1)\n\nbacterial_growth <- logistic_growth(K = 5000, N0 = 200, r = 0.43, time = time_vec)\n\n\n\n\n\nbacterial_df <- data.frame(time_vec, bacterial_growth)\n\nggplot(data = bacterial_df, aes(x = time_vec, y = bacterial_growth)) +\n  geom_point(aes(color = bacterial_growth))\n\n\n\n\nTry with multiple rate values\n\n\nr_seq <- seq(from = 0.20, to = 0.40, by = 0.01)\ntime_vec <- seq(from = 0, to = 35, by = 0.1)\n\nout_matrix <- matrix(ncol = length(r_seq), nrow = length(time_vec))\n\n# N0 = 100, K = 6000\nfor (i in seq_along(r_seq)) {\n  for (j in seq_along(time_vec)) {\n    pop <-logistic_growth(K = 6000, N0 = 100, r = r_seq[i], time = time_vec[j])\n    out_matrix[j, i] <- pop\n  }\n}\n\n# Wrangling\n\nout_df <- data.frame(time = time_vec, out_matrix)\n\n# Udpate col names\n\ncolnames(out_df) <- c(\"time\", paste0(\"gr_\", r_seq))\n\n# make a long form (tidy version) of this data\nout_df_long <- out_df %>% \n  pivot_longer(-time, names_to = \"growth_rate\", values_to = \"population\")\n\n# Make in ggplot a line graph (geom_line()) for pop over time with color depending on the growth rate\n\nggplot(data = out_df_long, aes(x = time, y = population)) +\n  geom_line(aes(color = growth_rate))\n\n\n\n\n\n\n\n",
    "preview": "posts/2021-08-26-some-r-functions/some-r-functions_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2021-08-26T21:36:31-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-08-23-christmas-gift-exchange/",
    "title": "Random Secret Santa R Script",
    "description": "A script I created to automate my family's yearly secret santa gift exchange",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-08-23",
    "categories": [],
    "contents": "\nMy family’s yearly gift exchange\nHere’s a little context needed to understand the program I created, before we get to the actual code.\nEach year my extended family does a secret santa gift exchange where each member of the family is randomly paired with another — the one parameter being that each person must be matched with someone outside of their nuclear family. The matches are assigned using the good old “pick a name from the hat” method. If you draw a name from within your immediate family, you try again until you get someone who isn’t. This process seemed like an excellent candidate for automation, and with a couple weeks of R under my belt, it felt like a perfect task to apply what I had learned so far.\nPackages used: tidyverse and here\n\n\nlibrary(tidyverse)\nlibrary(here)\n\n\n\nCreating data frame with family member’s and their corresponding family unit\nI read in a CSV that contains two variables we care about: Person and Group. Each family member is listed in the Person column, and the label created for their family unit under Group.\n\n\nxmas_names <- read_csv(here::here(\"data\", \"xmas_names.csv\")) %>% \n  select(Person, Group) \n\n\n\nCreating the function\nI want to create a function that outputs a data frame with two columns Giver and Recipient, that lists each member of my family and who they will be giving a gift to.\nLet’s start by preemptively creating this object before we get into the for loop. I’ve made a data frame of the proper dimensions, and also a vector that we’ll later populate with the names of those that have already been matched.\n\n\noutput_df <- data.frame(Giver = seq(1:nrow(xmas_names)), Recipient = seq(1:nrow(xmas_names)))\nalready_matched <- vector(mode = \"character\")\n\n\n\nFor loop\nWithin our function we’ll have a for loop that iterates through each row in our xmas_names data frame and randomly pairs the Person in each row with another person from outside of their immediate family unit.\nWe’ll iterate along the sequence 1:nrow(xmas_names)\nIn order to adjust our pool of “allowable” matches each iteration we’re going to create a temporary data frame, temp_names, that is first bound to xmas_names and then filtered based on our two criteria: the person cannot be in the same Group (family unit) and cannot have already been matched with someone else already. We’ll use dplyr::filter() to subset temp_names to meet these parameters.\n\n`temp_names <- xmas_names %>%`\n `filter(Group != xmas_names$Group[i]) %>%`\n `filter(!Person %in% already_matched)`\n\nNext, before the loop goes any further we’ll need to add an if statement that saves our function from hitting a dead end. Depending on the order in which matches are randomly assigned, sometimes only members of a single family unit remain in the final iterations. When this happens, our temp_names will be empty because there are no longer any viable matches, and our code will break.\n\n\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-08-24T23:16:14-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-08-10-a-function-i-learned/",
    "title": "User input as function arguments in R",
    "description": "A brief rundown of using readline() to prompt a user's input for use as function arguments",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-08-22",
    "categories": [],
    "contents": "\nLet’s create a simple function that outputs a statement containing a person’s name and the amount of change in their pocket given the number of each US coin they have\n\n\nspare_change <- function(friend, pennies, nickels, dimes, quarters) {\n\n  penny_val <- pennies * 0.01\n  nickel_val <- nickels * 0.05\n  dime_val <- dimes * 0.10\n  quarter_val <- quarters * 0.25\n\n  all_change <- sum(penny_val, nickel_val, dime_val, quarter_val)\n\n  return(paste(\"Your friend\", friend, \"has $\", all_change))\n}\n\n\n\nThis will work just fine, but that’s a lot of required arguments — we can make it a bit more user-friendly by prompting the user for input that will supply our arguments.\nThe readline() function takes input from the user which we can assign to an object. Within readline(), we define the argument prompt as the question or directive we want presented to the user. For example:\n\n\nfriend <- readline(prompt = \"what is your friend's name?\")\n\n\n\nIn the above example, friend is now assigned the value of whatever the user enters following the prompt.\nWe can use this same function to gather all the needed arguments for spare_change() by prompting the user for input. This will look like:\n\n\nspare_change <- function() {\n\n  friend <- readline(prompt = \"Enter a friend's name: \")\n  pennies <- as.numeric(readline(prompt = \"How many pennies do they have: \"))\n  nickels <- as.numeric(readline(prompt = \"How many nickels do they have: \"))\n  dimes <- as.numeric(readline(prompt = \"How many dimes do they have: \"))\n  quarters <- as.numeric(readline(prompt = \"How many quarters do they have: \"))\n\n  penny_val <- pennies * 0.01\n  nickel_val <- nickels * 0.05\n  dime_val <- dimes * 0.10\n  quarter_val <- quarters * 0.25\n\n  all_change <- sum(penny_val, nickel_val, dime_val, quarter_val)\n\n  return(paste(\"Your friend\", friend, \"has $\", all_change))\n}\n\n\n\nIt’s important to note that readline() returns a string, so for our coin value calculations, we had to convert the user’s input to a numeric value.\nOur function now requires no arguments when called — it will gather them from the user. Our user can run the function without using the documentation to determine what arguments are needed.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-08-23T19:05:57-07:00",
    "input_file": {}
  }
]
