[
  {
    "path": "posts/2021-08-23-christmas-gift-exchange/",
    "title": "Secret Santa R Script",
    "description": "A script I created to automate my family's yearly secret santa gift exchange",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-08-23",
    "categories": [
      "R"
    ],
    "contents": "\nMy family’s yearly gift exchange\nHere’s a little context needed to understand the program I created, before we get to the actual code.\nEach year my extended family does a secret santa gift exchange where each member of the family is randomly paired with another — the one caveat being that each person must be matched with someone outside of their nuclear family. Traditionally, the matches are assigned using the good old “pick a name from the hat” method. If you draw a name from within your immediate family, you try again until you get someone who isn’t. This process seemed like an excellent candidate for automation, and with a couple weeks of R under my belt, it felt like a perfect task to apply what I had learned so far.\nPackages used: tidyverse and here\n\n\nlibrary(tidyverse)\nlibrary(here)\n\n\n\nCreating data frame with family member’s and their corresponding family unit\nI read in a CSV that contains two variables we care about: Person and Group. Each family member is listed in the Person column, and the label created for their family unit under Group.\n\n\nxmas_names <- read_csv(here::here(\"data\", \"xmas_names.csv\")) %>% \n  select(Person, Group) \n\n\n\nCreating the function\nI want to create a function that outputs a data frame with two columns Giver and Recipient, that lists each member of my family and who they will be giving a gift to.\nLet’s start by preemptively creating this object, ouput_df, before we get into the for loop. I’ve made a data frame of the proper dimensions, and also a vector that we’ll later populate with the names of those that have already been matched.\n\n\noutput_df <- data.frame(Giver = seq(1:nrow(xmas_names)), Recipient = seq(1:nrow(xmas_names)))\nalready_matched <- vector(mode = \"character\")\n\n\n\nFor loop\nWithin our function we’ll have a for loop that iterates through each row in our xmas_names data frame and randomly pairs the Person in each row with another person from outside of their immediate family unit.\nWe’ll iterate along the sequence 1:nrow(xmas_names)\nIn order to adjust our pool of “allowable” matches each iteration we’re going to create a temporary data frame, temp_names, that is first bound to xmas_names and then filtered based on our two criteria: the person cannot be in the same Group (family unit) and cannot have already been matched with someone else already. We’ll use dplyr::filter() to subset temp_names to meet these parameters.\nNext, before the loop goes any further we’ll need to add an if statement that saves our function from hitting a dead end. Depending on the order in which matches are randomly assigned, sometimes only members of a single family unit remain in the final iterations. When this happens, our temp_names will be empty because there are no longer any viable matches, and our code will break. The if statement will just return our function when TRUE, so the function will continue to be called until we get a sequence of matches that works!\nNext we’re going to generate a random number using the sample() function and assign it to sample_number. This number will be used to index our random match. The number has to be in the range 1:nrow(temp_names) because temp_names is our temporary data frame of viable match candidates.\nWe’ll use sample_number to index temp_names$Person and assign that value to xmas_match. For consistency, we’ll assign the person currently being matched to matchee.\nNow we need to append() our current xmas_match to our vector already_matched which is used to filter temp_names so that person can’t be matched with anyone else.\n\n\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-09-29T14:04:53-07:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-08-10-user-input-within-functions/",
    "title": "User input as function arguments in R",
    "description": "A brief rundown of using readline() to prompt a user's input for use as function arguments",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-08-22",
    "categories": [
      "R",
      "Function I Learned"
    ],
    "contents": "\nLet’s create a simple function that outputs a statement containing a person’s name and the amount of change in their pocket given the number of each US coin they have\n\n\nspare_change <- function(friend, pennies, nickels, dimes, quarters) {\n\n  penny_val <- pennies * 0.01\n  nickel_val <- nickels * 0.05\n  dime_val <- dimes * 0.10\n  quarter_val <- quarters * 0.25\n\n  all_change <- sum(penny_val, nickel_val, dime_val, quarter_val)\n\n  return(paste(\"Your friend\", friend, \"has $\", all_change))\n}\n\n\n\nThis will work just fine, but that’s a lot of required arguments — we can make it a bit more user-friendly by prompting the user for input that will supply our arguments.\nThe readline() function takes input from the user which we can assign to an object. Within readline(), we define the argument prompt as the question or directive we want presented to the user. For example:\n\n\nfriend <- readline(prompt = \"what is your friend's name?\")\n\n\n\nIn the above example, friend is now assigned the value of whatever the user enters following the prompt.\nWe can use this same function to gather all the needed arguments for spare_change() by prompting the user for input. This will look like:\n\n\nspare_change <- function() {\n\n  friend <- readline(prompt = \"Enter a friend's name: \")\n  pennies <- as.numeric(readline(prompt = \"How many pennies do they have: \"))\n  nickels <- as.numeric(readline(prompt = \"How many nickels do they have: \"))\n  dimes <- as.numeric(readline(prompt = \"How many dimes do they have: \"))\n  quarters <- as.numeric(readline(prompt = \"How many quarters do they have: \"))\n\n  penny_val <- pennies * 0.01\n  nickel_val <- nickels * 0.05\n  dime_val <- dimes * 0.10\n  quarter_val <- quarters * 0.25\n\n  all_change <- sum(penny_val, nickel_val, dime_val, quarter_val)\n\n  return(paste(\"Your friend\", friend, \"has $\", all_change))\n}\n\n\n\nIt’s important to note that readline() returns a string, so for our coin value calculations, we had to convert the user’s input to a numeric value.\nOur function now requires no arguments when called — it will gather them from the user. Our user can run the function without using the documentation to determine what arguments are needed.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-09-29T13:43:40-07:00",
    "input_file": {}
  }
]
