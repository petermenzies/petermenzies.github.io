[
  {
    "path": "posts/2021-12-02-apisvsbombus/",
    "title": "Effects of managed honeybee colonies on bumblebee occurrence in the US",
    "description": "The following article details my statistical analysis of honeybee colonies and bumblebee occurrence in the US, using spatial interpolation and simple linear regression.",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-12-02",
    "categories": [
      "R",
      "Data Science"
    ],
    "contents": "\n\n\n\nBackground\nPollinator decline is among the world’s most pressing environmental issues. The creatures that fill this niche are necessary for the reproduction of roughly 85% of flowering plant species, and about three-fourths of the world’s staple crop species rely on them (US Forest Service). The services that pollinators provide in the US agricultural system were valued at $34 billion in 2012 (Jordan et al. 2021). That staggering figure doesn’t even include the value of the many ecosystems that hinge on their presence. Unfortunately, pollinator populations are declining world wide at alarming rates (Potts et al. 2010). Honeybees have become the poster child of this issue—and while the attention is well-deserved, the US is home to around 4000 native bee species, many of which are also facing population declines and are also highly important pollinators (US Forest Service). 49 of these species are members of the genus Bombus, commonly known as bumblebees. In addition to their general efficacy as pollen carriers, bumblebees are the sole pollinators of certain plants they have coevolved with. Flowers of plants like blueberries, tomatoes, pumpkins, and many others require what’s known as buzz pollination, or sonication—this means they need a bee to vibrate at a particular frequency to release their pollen (Vallejo-Marín 2019). Bombus species perform this form of pollination, making them invaluable to our native ecosystems and many important food crops.\nInterestingly, some studies have shown evidence that managed honeybees, which are nonnative, may be outcompeting native bees for resources (Angelella, McCullough, and O’Rourke 2021)(Mallinger, Gaines-Day, and Gratton 2017). It’s crucial that we understand everything that might be contributing to the decline of native bee species. The question this analysis investigates is: how does the number of managed honeybee colonies effect bumblebee occurrence in US counties?\nData\nThe analysis uses two different datasets—one containing managed honeybee colonies and the other bumblebee occurrence.\nThe honeybee data are originally from the USDA, and were tidied and made available on data.world by Brenda Grifith. The full dataset can be found here: https://data.world/siyeh/us-bee-stats-by-state/workspace/file?filename=Bee+Colony+Census+Data+by+County.csv. It contains the number of managed honeybee hives reported to the USDA Census of Agriculture per US county, in 2002, 2007, and 2012.\nThe bumblebee data, referred to as USBombus, are the result of a systematic nationwide survey of Bombus populations conducted for a 2011 study by Cameron et al. to determine the extent of bumblebee decline in the US. The dataset can be found here: https://www.gbif.org/dataset/c4a2c617-91a7-4d4f-90dd-a78b899f8545#temporalCoverages. It contains observations of bumblebee occurrence from sites in 40 of the contiguous states throughout a range of habitats and elevations, and includes coordinates associated with each observation. Specimens were captured on flowers and in flight using sweep nets. The survey took place between 2007 and 2010.\nMethods\nI chose to compare variations in honeybee colonies and bumblebee occurrence by location because the bumblebee data were collected over a number of years with little to no overlap in survey sites—thus, they don’t allow us to observe variation over time.\nBecause insect population densities can vary over small spatial ranges, I wanted to compare honeybee colonies and bumblebee occurrence at the finest resolution possible. In this case, the honeybee colony dataset limits us to the county level.\nDataset Approaches\nIn order to capture estimates of the number of managed honeybee colonies in the years surrounding the bumblebee survey, I calculated the mean number of colonies reported for each county from agriculture census years 2002, 2007, and 2012. Data from states that weren’t surveyed in USBombus were removed.\nDespite being one of the most extensive US bee surveys available, the USBombus data only represent occurrence in certain parts of certain counties. In order to estimate a more complete picture of bumblebee occurrence at the county level throughout much of the country, I chose to interpolate bumblebee occurrence using the survey data. Based on its spatial dispersion, the dataset appears to be a good candidate for this approach. I used ordinary Kriging, which several studies have successfully employed to predict insect occurrence (Pasini et al. 2021)(Zhang et al. 2007)(Zhou et al. 2012). To simplify the interpolation process, I limited the analysis to only counties within the conterminous US.\n\n\n\nInterpolation\nAfter summing the occurrence counts at each unique latitude and longitude in the bumblebee dataset, I used the autofitVariogram function in the automap package to create a fitted variogram model. I then created a grid with the spatial bounds of the bumblebee dataset composed of 0.4° x 0.4° cells. Using the krige() function in the gstats package I interpolated values of bumblebee occurrence onto the grid based on the variogram model. In order to derive a single estimated value of bumblebee occurrence in each county, I joined the interpolated output with a US counties dataset, and calculated the mean predicted occurrence in each county. I subsetted the resulting data to only states that were surveyed and only counties for which honeybee data were available by performing an inner join with the honeybee dataset. The interpolated mean bumblebee occurrence data are visualized below.\n\n\n\nFigure 1: This map represents mean bumblebee occurence by county based on spatial interpolation of the USBombus dataset. Only counties represented in the analysis are included.\n\n\n\nRegression\nI now have estimated values of bumblebee occurrence and managed honeybee colonies for all represented counties. After plotting the distributions of both sets of values, I determined that mean bumblebee occurrence appear to be normally distributed, and mean honeybee colonies appear to be log-normally distributed. I then regressed mean estimated bumblebee occurrence on mean honeybee colonies using ordinary least squares—the resulting visualization and summary table are below.\n\n\n\n\n\n\n\nFigure 2: This scatterplot compares the mean number of managed honeybee hives per US county from agriculture census years 2002, 2007, and 2012 vs mean bumblebee occurrence per county derived from spatial interpolation of a national bee survey conducted between 2007 and 2010.\n\n\n\n\n\n\n\n\n\nFigure 3:  This table presents the results of a simple linear regression of mean honeybee colonies per county on mean interpolated bumblebee occurrence per county.\n\n\n\n\n\n\n\nInterpreting results\nThe regression reveals a slight negative correlation. The correlation is statistically significant at a level of less than \\(0.05\\) and thus we can reject the null hypothesis that there is no relationship between the two samples. According to the model coefficients, a county with no managed honeybee colonies has a mean bumblebee occurrence of \\(47.19\\) individuals, and an increase of \\(1000\\) managed honeybee colonies results in a decrease of 0.04 individuals in mean bumblebee occurrence. The \\(R^2\\) value tells us that about \\(0.2\\)% of the variation in the interpolated mean bumblebee occurrence during the national survey is explained by mean managed honeybee colonies in 2002, 2007, and 2012.\nIn assessing our OLS assumptions, nothing in this analysis overtly suggests that assumption 1 (the population relationship is linear in parameters with an additive disturbance) or 2 (\\(x\\) variable is exogenous) are being violated. Additionally, we know that \\(x\\) has variation, satisfying assumption 3. Assumption 4, on the other hand, does not appear to be satisfied. The mean of the residuals is very close to \\(0\\), but looking at the residuals plotted against mean honeybee colonies reveals a higher variance in residuals close to \\(0\\) compared with that of greater values. The coefficient estimates may be unbiased, but the lowest variance property of OLS may not be upheld.\nAnalysis limitations\nWhile this analysis yielded a statistically significant result, there are some potential issues with the data and methods that need to be taken into consideration.\nThe large spatial scale of the analysis raises some possible concerns. The first of which being that the US is composed of widely different biomes with naturally varied concentrations of bumblebee species—a smaller geographic scope with more consistent habitat may provide better insight into this possible relationship by reducing the ambient variation in occurrence. Additionally, while I did find instances of ordinary Kriging being used to interpolate insect occurrence, I wasn’t able to find instances that reflected the scale used in my analysis. This warrants further investigation to better understand the limitations of ordinary Kriging as a tool for estimating insect occurrence.\nAnother possible complicating factor is the likelihood that most managed honeybee hives are located on private property, and many bumblebee survey sites tend to be on public lands. It’s possible that the foraging ranges of a large number of managed honeybee hives may not overlap at all with the bumblebee populations that were surveyed.\nThe time gaps in the honeybee data are also of concern. The Census of Agriculture only takes place every five years, and the number of honeybee colonies managed by a farming operation can vary greatly year to year—especially as of recently, due to Colony Collapse Disorder, varroa mite infestation, and pesticide use.\nConclusions and further analysis\nBecause of the analysis limitations, use of interpolated data, and the low coefficient of determination, I don’t think that this analysis is grounds to assert that managed honeybee colonies are having a broad-scale negative impact on bumblebee populations—I do, however, think that it warrants further investigation and experimental data collection.\nThese are rich datasets and there’s certainly much more to be gleaned from comparing them. To continue this investigation using the same data, I would try comparing honeybee and bumblebee estimates from similar ecoregions, in addition to exploring possible impacts on individual Bombus species. I would also like to explore other interpolation methods, such as the various forms of kriging discussed by Sciarretta and Trematerra in their 2014 analysis of geostatistical tools for studying insect spatial distribution. Given access to the relevant data, I would like to look at consistently surveyed bumblebee occurrence and managed hives within a relatively homogenous ecosystem, and to observe the relationship between their trends over time.\nRegardless of how it’s done, we need to do everything we can to understand the threats facing our native pollinators in order to mitigate their decline, and to preserve the invaluable services they provide.\nReferences\nAlex Jordan et al., “Economic Dependence and Vulnerability of United States Agricultural Sector on Insect-Mediated Pollination Service,” Environmental Science & Technology 55, no. 4 (February 16, 2021): 2243–53, https://doi.org/10.1021/acs.est.0c04786\n“Animal Pollination,” accessed December 1, 2021, https://www.fs.fed.us/wildflowers/pollinators/animals/index.shtml; “Bee Pollination,” accessed December 1, 2021, https://www.fs.fed.us/wildflowers/pollinators/animals/bees.shtml\n“Bee Colony Statistics - Dataset by Siyeh,” data.world, accessed November 25, 2021, https://data.world/siyeh/us-bee-stats-by-state; A. Sciarretta and P. Trematerra\nFabrice Vinatier et al., “Factors and Mechanisms Explaining Spatial Heterogeneity: A Review of Methods for Insect Populations: Factors and Mechanisms Explaining Spatial Heterogeneity,” Methods in Ecology and Evolution 2, no. 1 (January 2011): 11–22, https://doi.org/10.1111/j.2041-210X.2010.00059.x\n“Geostatistical Tools for the Study of Insect Spatial Distribution: Practical Implications in the Integrated Management of Orchard and Vineyard Pests,” Plant Protection Science 50, no. No. 2 (May 6, 2014): 97–110, https://doi.org/10.17221/40/2013-PPS\nG. M. Angelella, C. T. McCullough, and M. E. O’Rourke, “Honey Bee Hives Decrease Wild Bee Abundance, Species Richness, and Fruit Count on Farms Regardless of Wildflower Strips,” Scientific Reports 11, no. 1 (February 5, 2021): 3202, https://doi.org/10.1038/s41598-021-81967-1\nJonathan B. Koch, “USBombus, Contemporary Survey Data of North American Bumble Bees (Hymenoptera, Apidae, Bombus) Distributed in the United States,” accessed November 25, 2021, https://doi.org/10.15468/g8cnke\nMario Vallejo-Marín, “Buzz Pollination: Studying Bee Vibrations on Flowers,” New Phytologist 224, no. 3 (2019): 1068–74, https://doi.org/10.1111/nph.15666\nMauricio Paulo Batistella Pasini et al., “Semivariogram Models for Rice Stem Bug Population Densities Estimated by Ordinary Kriging,” Acta Scientiarum. Agronomy 43 (2021), https://www.redalyc.org/journal/3030/303067924025/html/\nSimon G. Potts et al., “Global Pollinator Declines: Trends, Impacts and Drivers,” Trends in Ecology & Evolution 25, no. 6 (June 1, 2010): 345–53, https://doi.org/10.1016/j.tree.2010.01.007./\nRong Zhang et al., “[Spatial structure analysis and distribution simulation of Therioaphis trifolii population based on geostatistics and GIS],” Ying Yong Sheng Tai Xue Bao = The Journal of Applied Ecology 18, no. 11 (November 2007): 2580–85\nRachel E. Mallinger, Hannah R. Gaines-Day, and Claudio Gratton, “Do Managed Bees Have Negative Effects on Wild Bees?: A Systematic Review of the Literature,” PLOS ONE 12, no. 12 (December 8, 2017): e0189268, https://doi.org/10.1371/journal.pone.0189268.\nS. A. Cameron et al., “Patterns of Widespread Decline in North American Bumble Bees,” Proceedings of the National Academy of Sciences 108, no. 2 (January 11, 2011): 662–67, https://doi.org/10.1073/pnas.1014743108\nWei Zhou et al., “Analysis of Spatial Pattern among Grasshopper and Vegetation in Heihe Based on GIS,” Physics Procedia 33 (2012): 1261–68, https://doi.org/10.1016/j.phpro.2012.05.208\n\n\n\n",
    "preview": "posts/2021-12-02-apisvsbombus/apis_vs_bombus_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2021-12-19T19:46:58-08:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/2021-12-20-iowa-wind-energy/",
    "title": "Assessing Iowa's potential for wind energy generation",
    "description": "A spatial analysis in python that estimates the theoretical amount of energy Iowa could produce via wind turbine.",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-12-01",
    "categories": [
      "Data Science",
      "Python",
      "Spatial Analysis"
    ],
    "contents": "\nNote: This analysis was originally a Jupyter notebook which I ported over to an Rmd. You can view the analysis in its original format here: iowa-wind-energy.ipynb\nLibraries\nimport sqlalchemy\nimport psycopg2\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport math\nObjective\nThe state of Iowa is both sparsely populated and has a landscape and wind speeds conducive to wind energy capture. The following analysis assesses the full potential that Iowa has to produce clean energy from wind turbines. This will give imortant insight to inform future wind energy development.\nMethods\nThe specifications of the Vestas V136-3.45 MW wind turbines will be used for the analysis. In order to identify viable space for wind turbines, we query a PostGIS database containing Iowa feature data extracted from OpenStreetMap. Suitable area is determined twice based on two different scenarios invoving spacing around residences. The first scenario (referred to here on as “scenario 1”) requires that turbines be three times their hub height away from residential buildings, and the second scenario (“scenario 2”) requires ten times the hub height. We query all areas unsuitable for turbines, compiling their geometries into a geodataframe, and subtract them from a grid representing Iowa that contains windspeed data. We then determine the possible number of wind turbines that could be placed in each cell of the grid, and use those values in conjunction with windspeeds to determine the amount of energy each cell could generate annually. Energy outputs are summed and we arrive at two figures representing total annual energy output for the two differnt scenarios.\nConnecting to database\nWe first establish our connection to the PostGIS database using the sqalchemy and psycopg2 libraries.\npg_uri_template = 'postgresql+psycopg2://{user}:{pwd}@{host}/{db_name}'\nuri = pg_uri_template.format(\n    host='128.111.89.111',\n    user='eds223_students',\n    pwd='eds223',\n    db_name='osmiowa'\n)\ndb = sqlalchemy.create_engine(uri)\nconnection = db.connect()\nSubqueries\nNext, we define each of our subqueries for the tables of interest in the database with the goal of compiling all areas that are not suitable for wind turbines. We use ST_BUFFER to incorporate the areas around certain features based on legal spatial constraints of turbine placement. Many these constraints are functions of the dimensions of the particular wind turbine model—those variables are defined for the model used in this analysis. We use two different residential queries that use different buffer sizes based on the two scenarios previously mentioned.\nHub height and rotor diameter of the Vestas V136-3.45 MW are stored as variables\nhub_height = 150 # meters\nrotor_diameter = 136 # meters\nHere we create our two residential subqueries that attempt to encompass all residential buildings defined in the database.\nresidential_query_3h = f\"\"\"\nSELECT ST_BUFFER(way, 3 * {hub_height}) \nFROM planet_osm_polygon\nWHERE building IN ('yes', 'residential', 'apartments', 'house', 'static_caravan', 'detached')\nOR landuse = 'residential'\nOR place = 'town'\n\"\"\"\nresidential_query_10h = f\"\"\"\nSELECT ST_BUFFER(way, 10 * {hub_height}) \nFROM planet_osm_polygon\nWHERE building IN ('yes', 'residential', 'apartments', 'house', 'static_caravan', 'detached')\nOR landuse = 'residential'\nOR place = 'town'\n\"\"\"\nNonresidential buildings require 3 * hub_height regardless of scenario.\nnonres_query = f\"\"\"\nSELECT ST_BUFFER(way, (3 * {hub_height})) \nFROM planet_osm_polygon\nWHERE building IS NOT NULL\nAND building NOT IN ('yes', 'residential', 'apartments', 'house', 'static_caravan', 'detached')\n\"\"\"\nBelow we create subqueries for airports, military areas, railroads, highways, nature reserves, parks, wetlands, water bodies, powerlines, powerplants, and exisitng wind turbines—along with their corresponding buffers.\nairport_query = \"\"\"\nSELECT ST_BUFFER(way, 7500)\nFROM planet_osm_polygon\nWHERE aeroway IS NOT NULL\n\"\"\"\nmilitary_query = \"\"\"\nSELECT ST_BUFFER(way, 0)\nFROM planet_osm_polygon\nWHERE (landuse = military) OR (military IS NOT NULL)\n\"\"\"\nrail_hwy_query = f\"\"\"\nSELECT ST_BUFFER(way, (2 * {hub_height}))\nFROM planet_osm_line\nWHERE railway = 'rail'\nOR highway IN ('trunk', 'motorway', 'primary', 'secondary')\nOR highway LIKE '%%link'\n\"\"\"\nreserves_parks_wetlands_query = \"\"\"\nSELECT ST_BUFFER(way, 0)\nFROM planet_osm_polygon\nWHERE \"natural\" IS NOT null\nAND leisure IS NOT null\n\"\"\"\nrivers_query = f\"\"\"\nSELECT ST_BUFFER(way, {hub_height})\nFROM planet_osm_line\nWHERE waterway = 'river'\n\"\"\"\nlake_query = \"\"\"\nSELECT ST_BUFFER(way, 0)\nFROM planet_osm_polygon\nWHERE water IN ('lake', 'pond', 'reservoir')\n\"\"\"\npowerline_query = f\"\"\"\nSELECT ST_BUFFER(way, (2 * {hub_height}))\nFROM planet_osm_line\nWHERE power IS NOT NULL\n\"\"\"\npowerplant_query = f\"\"\"\nSELECT ST_BUFFER(way, {hub_height})\nFROM planet_osm_polygon\nWHERE power IS NOT NULL\n\"\"\"\nwind_query = f\"\"\"\nSELECT ST_BUFFER(way, (5 * {rotor_diameter}))\nFROM planet_osm_point\nWHERE \"generator:source\" = 'wind'\n\"\"\"\nAggregated queries\nHere we create two aggregate queries by unioning our subqueries—one for scenario 1, and one for scenario 2.\nfull_query_3h = f\"\"\"\n{residential_query_3h}\nUNION\n{nonres_query}\nUNION\n{airport_query}\nUNION\n{military_query}\nUNION\n{rail_hwy_query}\nUNION\n{reserves_parks_wetlands_query}\nUNION\n{rivers_query}\nUNION\n{lake_query}\nUNION\n{powerline_query}\nUNION\n{powerplant_query}\nUNION\n{wind_query}\n\"\"\"\nfull_query_10h = f\"\"\"\n{residential_query_10h}\nUNION\n{nonres_query}\nUNION\n{airport_query}\nUNION\n{military_query}\nUNION\n{rail_hwy_query}\nUNION\n{reserves_parks_wetlands_query}\nUNION\n{rivers_query}\nUNION\n{lake_query}\nUNION\n{powerline_query}\nUNION\n{powerplant_query}\nUNION\n{wind_query}\n\"\"\"\nNext we query the database for both scenarios.\nsiting_constraints_3h = gpd.read_postgis(full_query_3h, con = connection, geom_col = 'st_buffer')\nsiting_constraints_10h = gpd.read_postgis(full_query_10h, con = connection, geom_col = 'st_buffer')\nWind speeds grid\nHere we query all columns from a table containing Iowa grid cells and average windspeeds for the regions they represent.\nwind_cells_query = \"\"\"\nSELECT * FROM wind_cells_10000\n\"\"\"\nwind_cells = gpd.read_postgis(wind_cells_query, con = connection, geom_col = 'geom')\nNext we subtract the unsuitable areas from the grid for both scenarios\nsuitable_cells_3h = wind_cells.overlay(siting_constraints_3h, how='difference')\nsuitable_cells_10h = wind_cells.overlay(siting_constraints_10h, how='difference')\nTaking a look at our suitable areas in scenario 1, with cells colored by wind speed:\nfig, ax = plt.subplots(figsize=(10, 10))\nax = suitable_cells_3h.plot(column='wind_speed', ax = ax)\n\nWind turbines need to be placed 5 rotor diameters apart. Below we calculate the necessary buffer area around each turbine—the buffer will have a radius of 2.5 * rotor_diameter so that adjoining buffers create a 5 * rotor_diameter distance between turbines. We then divide the suitable area of each cell by the buffer area to determine how many turbines can exist in them.\nturbine_buffer_radius = 2.5 * rotor_diameter\nturbine_buffer = math.pi * (turbine_buffer_radius ** 2)\nsuitable_cells_3h['possible_turbines'] = suitable_cells_3h.area / turbine_buffer\nsuitable_cells_10h['possible_turbines'] = suitable_cells_10h.area / turbine_buffer\nNext we use the equation \\(E = 2.6 s m-1 v + -5 GWh\\) to calcuate energy production per cell.\n\\(E\\) = energy production per turbine in GWh\n\\(v\\) = average annual wind speed in \\(m/s^-1\\)\nAnd then multiply the energy production per turbine by the number of possible turbines.\nsuitable_cells_3h['annual_energy_gwh'] = \\\n  ((2.6 * suitable_cells_3h['wind_speed']) - 5) * suitable_cells_3h['possible_turbines']\nsuitable_cells_10h['annual_energy_gwh'] = \\\n  ((2.6 * suitable_cells_10h['wind_speed']) - 5) * suitable_cells_10h['possible_turbines']\nThe energy production of all cells is summed and the final results we arrived at are printed below:\ntotal_annual_energy_3h = suitable_cells_3h['annual_energy_gwh'].sum().round(5)\n\nprint(f\"\"\"Total possible annual wind energy production\n      in Iowa given scenario 1: {total_annual_energy_3h} GWh/yr\"\"\")\nTotal possible annual wind energy production in Iowa given scenario 1: 4322397.04441 GWh/yr\ntotal_annual_energy_10h = suitable_cells_10h['annual_energy_gwh'].sum().round(5)\n\nprint(f\"\"\"Total possible annual wind energy production \n      in Iowa given scenario 2: {total_annual_energy_10h} GWh/yr\"\"\")\nTotal possible annual wind energy production in Iowa given scenario 2: 3922073.53289 GWh/yr\nConclusions\nAccording to Energy.gov and the EIA, Iowa’s annual energy use is 45.7 TWh, and the total for the US is 27,238.9 TWh\n# Determining how our scenario 2 values compare with Iowa's and the US's expenditures\ntotal_annual_energy_twh = total_annual_energy_10h / 1000\niowa_factor = total_annual_energy_twh / 45.7\nprint(iowa_factor)\n\nus_factor = total_annual_energy_twh / 27238.9\nprint(us_factor)\n85.82217796258205\n0.14398795593397676\nBased on even the more conservative scenario in this analysis, using all viable space in Iowa for wind turbines would generate roughly 85.8 times the annual energy expenditure of the state, and about 14.4% of the annual energy expenditure of the entire country.\nThese figures convey the incredible potential for wind energy capture in Iowa and other similar regions.\n\n\n\n",
    "preview": "posts/2021-12-20-iowa-wind-energy/files/output_38_0.png",
    "last_modified": "2021-12-20T12:05:07-08:00",
    "input_file": {},
    "preview_width": 607,
    "preview_height": 413
  },
  {
    "path": "posts/2021-08-23-christmas-gift-exchange/",
    "title": "Secret Santa R Script",
    "description": "A script I created to automate my family's yearly secret santa gift exchange 🎄",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-08-23",
    "categories": [
      "R"
    ],
    "contents": "\nA litle context…\nEvery year my extended family does a gift exchange where each member of the family is randomly paired with another member—the one caveat being that each person must be matched with someone outside of their immediate family. Traditionally, the matches are assigned using the good old “pick a name from a hat” method. If you draw a name from within your immediate family, you try again until you get someone who isn’t. This process seemed like an excellent candidate for automation, and with a couple weeks of R under my belt it felt like a perfect project to apply what I had learned so far.\nPackages used: tidyverse, here, and gt\n\n\nlibrary(tidyverse)\nlibrary(here)\nlibrary(gt)\n\n\n\nReading in data\nFirstly, I read in a CSV that contains two variables we care about: Person and Group. Each family member is listed in the Person column, and the label created for their family unit under Group.\n\n\nxmas_names <- read_csv(here(\"data\", \"xmas_names.csv\")) %>% \n  select(Person, Group) \n\n\n\nCreating the function\nI want to create a function that outputs a dataframe with two columns, Giver and Recipient, that lists each member of the family and who they will be giving a gift to. Let’s call the function match_maker.\nThe function will first create the framework of the aforementioned ouput_df and a vector that we’ll populate with the names of those that have already been matched.\n\nmatch_maker <- function() {\n\n  output_df <- data.frame(Giver = seq(1:nrow(xmas_names)), Recipient = seq(1:nrow(xmas_names)))\n  already_matched <- vector(mode = \"character\")\n\nFor loop\nWithin our function we’ll have a for loop that iterates through each row in our xmas_names dataframe and randomly pairs the Person in each row with another person from outside of their immediate family unit (Group).\nThe loop will iterate along the sequence 1:nrow(xmas_names).\nIn order to adjust our pool of “allowable” matches within each iteration, we’re going to create a temporary dataframe—temp_names—that is first assigned to xmas_names and then filtered based on our two criteria: the person isn’t in the same Group and hasn’t been matched already. We’ll use dplyr::filter() to subset temp_names to meet these parameters.\n\n  for (i in 1:nrow(xmas_names)) {\n    \n    temp_names <- xmas_names %>%\n      filter(Group != xmas_names$Group[i]) %>% \n      filter(!Person %in% already_matched)\n\nNext, before the loop goes any further we’ll need to add an if statement that saves our function from hitting a dead end. Depending on the order in which matches are randomly assigned, it’s possible for only members of a single family unit to remain in the final iterations. When this happens, our temp_names dataframe will be empty because there are no longer any viable matches, and our code will break. The if statement will restart the function if temp_names becomes empty before all people have been matched.\n\n    if (nrow(temp_names) == 0) {\n      return(match_maker())\n\nNext we’re going to generate a random number using the sample() function and assign it to sample_number. We’ll use this number to index temp_names$Person and assign that value to match. sample_number has to be in the range 1:nrow(temp_names) because temp_names is our temporary dataframe of viable match candidates. The person being matched we can call matchee.\nAnd we need to append() our current match to our vector already_matched which is used to filter temp_names so that person can’t be selected as a recipient again.\n\n    }\n    \n    sample_number <- sample(1:nrow(temp_names), 1)\n    \n    match <- temp_names$Person[sample_number]\n    \n    matchee <- xmas_names[[i, 1]]\n    \n    already_matched <- append(already_matched, match)\n\nLastly, we’ll add matchee and match to the output_df, and instruct the function to return output_df once the for loop has iterated through all names on the list.\n\n    output_df$Giver[i] <- matchee\n    output_df$Recipient[i] <- match\n    \n  }\n  \n  return(output_df)\n  \n}\n\nFunction in full:\n\n\nmatch_maker <- function() {\n\n  output_df <- data.frame(Giver = seq(1:nrow(xmas_names)), Recipient = seq(1:nrow(xmas_names)))\n  already_matched <- vector(mode = \"character\")\n  \n  for (i in 1:nrow(xmas_names)) {\n    \n    temp_names <- xmas_names %>%\n      filter(Group != xmas_names$Group[i]) %>% \n      filter(!Person %in% already_matched)\n    \n    if (nrow(temp_names) == 0) {\n      return(match_maker())\n    }\n    \n    sample_number <- sample(1:nrow(temp_names), 1)\n    \n    match <- temp_names$Person[sample_number]\n    \n    matchee <- xmas_names[[i, 1]]\n    \n    already_matched <- append(already_matched, match)\n    \n    output_df$Giver[i] <- matchee\n    output_df$Recipient[i] <- match\n    \n  }\n  \n  return(output_df)\n  \n}\n\n\n\nThe result:\nNow let’s make some matches! (I used gt() here just to create a nice table for the output)\n\n\nmatch_maker() %>% gt()\n\n\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#jtmacmrmzm .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#jtmacmrmzm .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#jtmacmrmzm .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#jtmacmrmzm .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#jtmacmrmzm .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#jtmacmrmzm .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#jtmacmrmzm .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#jtmacmrmzm .gt_group_heading {\n  padding: 8px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#jtmacmrmzm .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#jtmacmrmzm .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#jtmacmrmzm .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#jtmacmrmzm .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#jtmacmrmzm .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 12px;\n}\n\n#jtmacmrmzm .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#jtmacmrmzm .gt_first_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#jtmacmrmzm .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#jtmacmrmzm .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding: 4px;\n}\n\n#jtmacmrmzm .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#jtmacmrmzm .gt_sourcenote {\n  font-size: 90%;\n  padding: 4px;\n}\n\n#jtmacmrmzm .gt_left {\n  text-align: left;\n}\n\n#jtmacmrmzm .gt_center {\n  text-align: center;\n}\n\n#jtmacmrmzm .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#jtmacmrmzm .gt_font_normal {\n  font-weight: normal;\n}\n\n#jtmacmrmzm .gt_font_bold {\n  font-weight: bold;\n}\n\n#jtmacmrmzm .gt_font_italic {\n  font-style: italic;\n}\n\n#jtmacmrmzm .gt_super {\n  font-size: 65%;\n}\n\n#jtmacmrmzm .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 65%;\n}\nGiver\n      Recipient\n    Anna\nCasey OPhil\nLaurieHolt\nKateCasey B\nRachelPeter\nSteveRobbie\nPhilLaurie\nPeterAustin\nClaireCasey O\nJamesJesse\nJasonKevin\nHoltSteve\nDavidPam\nLukeJustin\nRobbieHilary\nBarbaraAdam\nTommyClaire\nJesseTommy\nAdamBarbara\nAnnaJason\nKevinLaura\nHilaryLuke\nPamRachel\nAustinJames\nCasey BKate\nJustinDavid\nLaura\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-12-19T19:35:56-08:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-08-10-user-input-within-functions/",
    "title": "User input as function arguments in R",
    "description": "A brief rundown of using readline() to prompt a user's input for use as function arguments",
    "author": [
      {
        "name": "Peter Menzies",
        "url": {}
      }
    ],
    "date": "2021-08-22",
    "categories": [
      "R",
      "Function I Learned"
    ],
    "contents": "\nLet’s create a simple function that outputs a statement containing a person’s name and the amount of change in their pocket given the number of each US coin they have\n\n\nspare_change <- function(friend, pennies, nickels, dimes, quarters) {\n\n  penny_val <- pennies * 0.01\n  nickel_val <- nickels * 0.05\n  dime_val <- dimes * 0.10\n  quarter_val <- quarters * 0.25\n\n  all_change <- sum(penny_val, nickel_val, dime_val, quarter_val)\n\n  return(paste(\"Your friend\", friend, \"has $\", all_change))\n}\n\n\n\nThis will work just fine, but that’s a lot of required arguments — we can make it a bit more user-friendly by prompting the user for input that will supply our arguments.\nThe readline() function takes input from the user which we can assign to an object. Within readline(), we define the argument prompt as the question or directive we want presented to the user. For example:\n\n\nfriend <- readline(prompt = \"what is your friend's name?\")\n\n\n\nIn the above example, friend is now assigned the value of whatever the user enters following the prompt.\nWe can use this same function to gather all the needed arguments for spare_change() by prompting the user for input. This will look like:\n\n\nspare_change <- function() {\n\n  friend <- readline(prompt = \"Enter a friend's name: \")\n  pennies <- as.numeric(readline(prompt = \"How many pennies do they have: \"))\n  nickels <- as.numeric(readline(prompt = \"How many nickels do they have: \"))\n  dimes <- as.numeric(readline(prompt = \"How many dimes do they have: \"))\n  quarters <- as.numeric(readline(prompt = \"How many quarters do they have: \"))\n\n  penny_val <- pennies * 0.01\n  nickel_val <- nickels * 0.05\n  dime_val <- dimes * 0.10\n  quarter_val <- quarters * 0.25\n\n  all_change <- sum(penny_val, nickel_val, dime_val, quarter_val)\n\n  return(paste(\"Your friend\", friend, \"has $\", all_change))\n}\n\n\n\nIt’s important to note that readline() returns a string, so for our coin value calculations, we had to convert the user’s input to a numeric value.\nOur function now requires no arguments when called — it will gather them from the user. Our user can run the function without using the documentation to determine what arguments are needed.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-09-29T13:43:40-07:00",
    "input_file": {}
  }
]
